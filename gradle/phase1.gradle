import at.bxm.gradleplugins.svntools.tasks.SvnAdd
import at.bxm.gradleplugins.svntools.tasks.SvnCheckout
import at.bxm.gradleplugins.svntools.tasks.SvnCommit
import at.bxm.gradleplugins.svntools.api.SvnDepth
import static groovyx.net.http.ContentType.*
import org.apache.tools.ant.taskdefs.condition.Os
import org.ajoberstar.grgit.Person
import org.ajoberstar.grgit.util.JGitUtil

buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath 'org.ajoberstar:grgit:1.7.0'
        classpath 'at.bxm.gradleplugins:gradle-svntools-plugin:2.1'
        classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.7.1'
    }
}

apply plugin: "at.bxm.svntools"
apply plugin: 'signing'

svntools {
    username = apacheUser
    password = apachePassword
}

task init {
    assert project.hasProperty('branch')
    rootProject.ext.branch = project.getProperty('branch')
    rootProject.ext.stagingDir = "$project.buildDir/staging-$branch/"
    System.setProperty('org.ajoberstar.grgit.auth.username', apacheUser)
    System.setProperty('org.ajoberstar.grgit.auth.password', apachePassword)
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        System.setProperty('https.protocols', 'TLSv1.1')
    }
}

task checkout(dependsOn: init) {
    group = "Pre-vote phase"
    description = "Checks out the Apache Groovy sources (assumes -Pbranch=branch_to_release)"
    // fresh clone may be overkill but take safe option for now unless skipClone specified
    doLast {
        def grgit
        if (rootProject.hasProperty('skipClone')) {
            grgit = grgitClass.open(dir: stagingDir)
        } else {
            println "Cloning $repoUri to $stagingDir. This may take a few minutes ..."
            grgit = grgitClass.clone(dir: stagingDir, uri: repoUri, refToCheckout: branch)
        }
        grgit.checkout(branch: rootProject.getProperty('branch'))
        def id = grgit.head().abbreviatedId
        def message = grgit.head().shortMessage
        def dir = file(stagingDir)
        assert !dir.isFile() && dir.listFiles()
        println "Checked out: $grgit.branch.current.name @ $id ($message)"
    }
}

task confirmVersion {
    group = "Pre-vote phase"
    description = "Confirm version to release (assumes -PreleaseVersion=version_to_release)"
    assert rootProject.hasProperty('releaseVersion')
    rootProject.ext.relVersion = rootProject.getProperty('releaseVersion')
    rootProject.ext.numVersion = relVersion.find(/^[\d\.]+/)
    rootProject.ext.underVersion = relVersion.replace('.', '_').replace('-', '_').toUpperCase()
    rootProject.ext.releaseBuild = !relVersion.toLowerCase().contains('snapshot')
    dependsOn checkout
    doLast {
        def propsFile = file("$stagingDir/gradle.properties")
        def versionLines = propsFile.text.readLines().findAll{ it.matches(/groovy.*Version.*/) }
        def normalVersion = /(?ism).*$numVersion[a-zA-Z\-]*\.SNAPSHOT.*/
        def bundleVersion = /(?ism).*$numVersion[a-zA-Z\-]*-SNAPSHOT.*/
        versionLines.each {
            assert it.matches(normalVersion) || it.matches(bundleVersion)
        }
    }
}

task jiraPrecheck {
    dependsOn confirmVersion
    doLast {
        def jira = new groovyx.net.http.RESTClient('https://issues.apache.org/jira/rest/api/2/')
        def resp = jira.get(path: 'project/GROOVY/versions')
        assert resp.status == 200
        def versionFields = resp.data.find{ it.name == relVersion }
        assert versionFields, "Version $relVersion not found in Jira!"
        assert !versionFields.released, "Version $relVersion already released!"
        rootProject.ext.versionId = versionFields.id
        rootProject.ext.projectId = versionFields.projectId

        resp = jira.get(path: "version/$versionId/unresolvedIssueCount")
        assert resp.data
        if (resp.data.issuesUnresolvedCount) {
            logger.warn "Warning found $resp.data.issuesUnresolvedCount unresolved issues for version $relVersion"
        }
        resp = jira.get(path: "version/$versionId/relatedIssueCounts")
        assert resp.data
        rootProject.ext.fixCount = resp.data.issuesFixedCount
    }
}

task createReleaseBranch {
    group = "Pre-vote phase"
    description = "Creates a release branch"
    dependsOn jiraPrecheck
    doLast {
        def grgit = grgitClass.open(dir: stagingDir)
        grgit.checkout(branch: "REL_BRANCH_$underVersion", startPoint: branch, createBranch: true)
        println "Checked out: $grgit.branch.current.name"
    }
}

task updateVersionProperties {
    group = "Pre-vote phase"
    description = "Promotes versions to non SNAPSHOT in gradle.properties and commits the result"
    dependsOn createReleaseBranch
    doLast {
        def propsFile = file("$stagingDir/gradle.properties")
        def propsText = propsFile.text
        propsText = propsText.replace(numVersion + '-SNAPSHOT', relVersion)
        propsText = propsText.replace(numVersion + '.SNAPSHOT', relVersion)
        propsFile.text = propsText
        def grgit = grgitClass.open(dir: stagingDir)
        grgit.add(patterns: ['gradle.properties'])
        def commit = grgit.commit(message: "Release $relVersion: update versions")
        println "@ $commit.abbreviatedId ($commit.shortMessage)"
    }
}
[jiraPrecheck, createReleaseBranch, updateVersionProperties]*.onlyIf{ project.hasProperty('releaseBuild') && releaseBuild }

// use Exec rather the GradleBuild to ensure we use the correct gradle version for the groovy version being built
task buildAndUpload(type: Exec) {
    group = "Pre-vote phase"
    description = "Builds Apache Groovy and publishes the Maven artifacts to the staging repository on Bintray"
    dependsOn updateVersionProperties
    workingDir stagingDir
    ext.theArgs = []
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        theArgs += ['cmd', '/C', 'gradlew.bat']
    } else {
        theArgs << 'gradlew'
    }
    theArgs << "-PbintrayUser=$bintrayUser"
    theArgs << "-PbintrayKey=$bintrayPassword"
    theArgs << "-PbintrayContext=https://groovy.jfrog.io/groovy/"
    theArgs << "-PbintrayRepoKey=${releaseBuild ? 'libs-release-local' : 'libs-snapshot-local'}"
    theArgs += ['install', 'dist', 'artifactoryPublish']
    commandLine theArgs
}

task cleanSvnDevWorkspace(type: Delete) {
    dependsOn buildAndUpload
    dependsOn init
    project.ext.devWorkspaceRoot = "$project.buildDir/svn-dev-workspace-$branch"
    delete devWorkspaceRoot
}

task prepareSvnDevWorkspace(type: SvnCheckout, dependsOn: cleanSvnDevWorkspace) {
    svnUrl = "https://dist.apache.org/repos/dist/dev/groovy"
    workspaceDir = devWorkspaceRoot
    rootProject.ext.devWorkspace = "$devWorkspaceRoot/$relVersion"
    depth = SvnDepth.FILES // slightly more efficient if we have two concurrent releases (e.g. 2.4.latest, 2.5.0)
}

task copySvnDistro(type: Copy, dependsOn: prepareSvnDevWorkspace) {
    description = "Creates the required tree structure for distribution"
        from ("$stagingDir/target/distributions")
        into "$devWorkspace/distribution"
        exclude 'apache-groovy-src-*'
    }

task copySvnSources(type: Copy, dependsOn: prepareSvnDevWorkspace) {
    description = "Creates the required tree structure for sources"
        from ("$stagingDir/target/distributions")
        into "$devWorkspace/sources"
        include 'apache-groovy-src-*'
    }

task addSvnFiles(type: SvnAdd, dependsOn: [copySvnDistro, copySvnSources]) {
    // TODO check whether this is needed since commit seems to do an add anyway?
    description = "Adds the changed files to svn"
    add devWorkspace
    recursive true
}

task createChecksumsAndSign {
    group = "Pre-vote phase"
    description = "Creates SHA-256 checksums for all artifacts"
    dependsOn addSvnFiles
    doLast {
        fileTree(devWorkspace).files.each {
            ant.checksum file: it, algorithm: 'SHA-256'
            signing.sign(it)
        }
    }
}

task uploadToApacheDevServers {
    dependsOn createChecksumsAndSign
    group = "Pre-vote phase"
    description = "Commits the changed files to the Apache dist dev server"
    doLast {
        // less declarative than ideal but we want deferred operation since
        // svn plugin assumes list of files to commit is known at config time
        // TODO: create feature request for svn plugin for depth argument or add source directory with recursive
        def uploadBuild = project.tasks.create(name: "uploadBuild", type: GradleBuild)
        uploadBuild.startParameter.projectProperties = gradle.startParameter.projectProperties
        uploadBuild.tasks = ['uploadToApacheDevServersInternal']
        uploadBuild.execute()
    }
}

task uploadToApacheDevServersInternal(type: SvnCommit) {
    source << devWorkspace
    def tree = fileTree(devWorkspace).include('**/*')
    tree.visit {
        source << "$devWorkspace/$it.path"
    }
    commitMessage = "New version $branch $relVersion added"
}

task createAndPushTag {
    group = "Pre-vote phase"
    description = "Creates a release tag and pushes it to the Apache Git repository"
    dependsOn uploadToApacheDevServers
    doLast {
        def grgit = grgitClass.open(dir: stagingDir)
        def tagName = "GROOVY_$underVersion"
        def tag = null
        try {
            tag = JGitUtil.resolveTag(grgit.repository, tagName)
        } catch(ignore) {}
        assert !tag, "Tag $tagName already found!"
        tag = grgit.tag.add(name: tagName,
                message: "Release Groovy $relVersion",
                tagger: new Person(apacheUser, apacheUser + '@apache.org')
        )
        project.ext.tagId = tag.commit.id
        grgit.push(tags: true)
    }
}

task releaseOnJira {
    group = "Pre-vote phase"
    description = "Releases the version on JIRA"
    dependsOn createAndPushTag
    doLast {
        def jira = new groovyx.net.http.RESTClient('https://issues.apache.org/jira/rest/api/2/')
        jira.headers['Authorization'] = 'Basic '+"$apacheUser:$apachePassword".getBytes('iso-8859-1').encodeBase64()
        def resp = jira.put(
                path: "version/$versionId",
                body: /{ "released": true, "releaseDate": "$now" }/,
                requestContentType: JSON
        )
        assert resp.status == 200
    }
}

task prepareVoteThread {
    group = "Pre-vote phase"
    description = "Generates a [VOTE] thread to be tweaked and sent to the dev@ mailing list"
    dependsOn releaseOnJira
    doLast {
        println """
Below is a template email to tweak and send to the dev@ mailing list as a [VOTE] thread.
If the vote passes after 72h, proceed with phase2.
If the vote fails or the release is cancelled, manually unrelease the version from Jira and start again.

---------------- >8 -----------------

Dear community,

I am happy to start the VOTE thread for a Groovy $relVersion release!

This release includes $fixCount bug fixes/improvements as outlined in the changelog:
https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=$projectId&version=$versionId

Tag: $repoBase?p=groovy.git;a=tag;h=refs/tags/GROOVY_$underVersion
Tag commit id: $tagId

The artifacts to be voted on are located as follows.
Source release: https://dist.apache.org/repos/dist/dev/groovy/$relVersion/sources
Convenience binaries: https://dist.apache.org/repos/dist/dev/groovy/$relVersion/distribution

Release artifacts are signed with the following key: https://dist.apache.org/repos/dist/dev/groovy/KEYS

Please vote on releasing this package as Apache Groovy $relVersion.

The vote is open for the next 72 hours and passes if a majority of at least three +1 PMC votes are cast.

[ ] +1 Release Apache Groovy $relVersion
[ ]  0 I don't have a strong opinion about this, but I assume it's ok
[ ] -1 Do not release Apache Groovy $relVersion because...

Here is my vote:

+1 (binding)

---------------- >8 -----------------
"""
    }
}

[createAndPushTag, releaseOnJira, prepareVoteThread]*.onlyIf{ project.hasProperty('releaseBuild') && releaseBuild }
