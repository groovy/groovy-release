import at.bxm.gradleplugins.svntools.tasks.SvnCheckout
import at.bxm.gradleplugins.svntools.tasks.SvnCommit
import at.bxm.gradleplugins.svntools.tasks.SvnAdd

buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath 'org.ajoberstar:grgit:1.7.0'
        classpath 'at.bxm.gradleplugins:gradle-svntools-plugin:2.1'
        classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.7.1'
    }
}

apply plugin: "at.bxm.svntools"
apply plugin: 'signing'

svntools {
    username = svnUsername
    password = svnPassword
}

task init {
    assert project.hasProperty('branch')
    rootProject.ext.branch = project.getProperty('branch')
    rootProject.ext.stagingDir = "$project.buildDir/staging-$branch/"
}

task checkout(dependsOn: init) {
    group = "Pre-vote phase"
    description = "Checks out the Apache Groovy sources (assumes -Pbranch=branch_to_release)"
    // fresh clone may be overkill but take safe option for now unless skipClone specified
    doLast {
        def grgit
        if (rootProject.hasProperty('skipClone')) {
            grgit = grgitClass.open(dir: stagingDir)
        } else {
            println "Cloning $repoUri to $stagingDir. This may take a few minutes ..."
            grgit = grgitClass.clone(dir: stagingDir, uri: repoUri, refToCheckout: branch)
        }
        grgit.checkout(branch: rootProject.getProperty('branch'))
        def id = grgit.head().abbreviatedId
        def message = grgit.head().shortMessage
        def dir = file(stagingDir)
        assert !dir.isFile() && dir.listFiles()
        println "Checked out: $grgit.branch.current.name @ $id ($message)"
    }
}

task confirmVersion {
    group = "Pre-vote phase"
    description = "Confirm version to release (assumes -PreleaseVersion=version_to_release)"
    assert rootProject.hasProperty('releaseVersion')
    rootProject.ext.relVersion = rootProject.getProperty('releaseVersion')
    rootProject.ext.numVersion = relVersion.find(/^[\d\.]+/)
    rootProject.ext.releaseBuild = !relVersion.toLowerCase().contains('snapshot')
    dependsOn checkout
    doLast {
        def propsFile = file("$stagingDir/gradle.properties")
        def versionLines = propsFile.text.readLines().findAll{ it.matches(/groovy.*Version.*/) }
        def normalVersion = /(?sm).*$numVersion[a-zA-Z\-]*\.SNAPSHOT.*/
        def bundleVersion = /(?sm).*$numVersion[a-zA-Z\-]*-SNAPSHOT.*/
        versionLines.each {
            assert it.matches(normalVersion) || it.matches(bundleVersion)
        }
    }
}

task jiraPrecheck {
    dependsOn confirmVersion
    doLast {
        def jira = new groovyx.net.http.RESTClient('https://issues.apache.org/jira/rest/api/2/')
        def resp = jira.get(path: 'project/GROOVY/versions')
        assert resp.status == 200
        def versionFields = resp.data.find{ it.name == relVersion }
        assert versionFields, "Version $relVersion not found in Jira!"
        assert !versionFields.released, "Version $relVersion already released!"
        rootProject.ext.versionId = versionFields.id

        resp = jira.get(path: "version/$versionId/unresolvedIssueCount")
        assert resp.data
        if (resp.data.issuesUnresolvedCount) {
            logger.warn "Warning found $resp.data.issuesUnresolvedCount unresolved issues for version $relVersion"
        }
    }
}

task createReleaseBranch {
    group = "Pre-vote phase"
    description = "Creates a release branch"
    dependsOn jiraPrecheck
    doLast {
        def grgit = grgitClass.open(dir: stagingDir)
        grgit.checkout(branch: "REL-BRANCH-$relVersion", startPoint: branch, createBranch: true)
        println "Checked out: $grgit.branch.current.name"
    }
}

task updateVersionProperties {
    group = "Pre-vote phase"
    description = "Promotes versions to non SNAPSHOT in gradle.properties and commits the result"
    dependsOn createReleaseBranch
    doLast {
        def propsFile = file("$stagingDir/gradle.properties")
        def propsText = propsFile.text
        propsText = propsText.replace(relVersion + '-SNAPSHOT', relVersion)
        propsText = propsText.replace(relVersion + '.SNAPSHOT', relVersion)
        propsFile.text = propsText
        def grgit = grgitClass.open(dir: stagingDir)
        grgit.add(patterns: ['gradle.properties'])
        def commit = grgit.commit(message: "Release $relVersion: update versions")
        println "@ $commit.abbreviatedId ($commit.shortMessage)"
    }
}
[jiraPrecheck, createReleaseBranch, updateVersionProperties]*.onlyIf{ project.hasProperty('releaseBuild') && releaseBuild }

task buildAndUpload {
    group = "Pre-vote phase"
    description = "Builds Apache Groovy and publishes the Maven artifacts to the staging repository on Bintray"
    dependsOn updateVersionProperties
    doLast {
        // less declarative than ideal but using 'type: GradleBuild' on the
        // task confuses jarAllWithIndy which does use the declarative approach
        def groovyBuild = project.tasks.create(name: "groovyBuild", type: GradleBuild)
        groovyBuild.dir = file(stagingDir)
        groovyBuild.tasks = ['install', 'dist', 'artifactoryPublish']
        groovyBuild.execute()
    }
}

task cleanSvnWorkspace(type: Delete) {
    dependsOn buildAndUpload
    dependsOn init
    delete "$project.buildDir/svn-workspace-$branch"
}

task prepareSvnWorkspace(type: SvnCheckout, dependsOn: cleanSvnWorkspace) {
    svnUrl = "https://dist.apache.org/repos/dist/dev/groovy"
    workspaceDir = "$project.buildDir/svn-workspace-$branch"
}

task copySvnDistro(type: Copy, dependsOn: prepareSvnWorkspace) {
    description = "Creates the required tree structure for distribution"
        from ("$stagingDir/target/distributions")
        into "$project.buildDir/svn-workspace-$branch/$relVersion/distribution"
        exclude 'apache-groovy-src-*'
    }

task copySvnSources(type: Copy, dependsOn: prepareSvnWorkspace) {
    description = "Creates the required tree structure for sources"
        from ("$stagingDir/target/distributions")
        into "$project.buildDir/svn-workspace-$branch/$relVersion/sources"
        include 'apache-groovy-src-*'
    }

task addSvnFiles(type: SvnAdd, dependsOn: [copySvnDistro, copySvnSources]) {
    // TODO check whether this is needed since commit seems to do an add anyway?
    description = "Adds the changed files to svn"
    add "$project.buildDir/svn-workspace-$branch/$relVersion/"
    recursive true
}

task createChecksums {
    group = "Pre-vote phase"
    description = "Creates SHA-256 checksums for all artifacts"
    dependsOn addSvnFiles
    doLast {
        fileTree("$project.buildDir/svn-workspace-$branch/$relVersion/").files.each {
            ant.checksum file: it, algorithm: 'SHA-256'
        }
    }
}

task signDistribution {
    group = "Pre-vote phase"
    description = "Signs the artifacts"
    dependsOn createChecksums
    doLast {
        fileTree("$project.buildDir/svn-workspace-$branch/$relVersion/").files.each {
            signing.sign(it)
        }
    }
}

task uploadToApacheDevServers {
    dependsOn signDistribution
    group = "Pre-vote phase"
    description = "Commits the changed files to the Apache dist dev server"
    doLast {
        // less declarative than ideal but we want deferred operation since
        // svn plugin assumes list of files to commit is known at config time
        // TODO: create feature request for svn plugin for depth argument or add source directory with recursive
        def uploadBuild = project.tasks.create(name: "groovyBuild", type: GradleBuild)
        uploadBuild.startParameter.projectProperties = gradle.startParameter.projectProperties
        uploadBuild.tasks = ['uploadToApacheDevServersInternal']
        uploadBuild.execute()
    }
}

task uploadToApacheDevServersInternal(type: SvnCommit) {
    source << "$project.buildDir/svn-workspace-$branch/$relVersion/"
    def tree = fileTree("$project.buildDir/svn-workspace-$branch/$relVersion/").include('**/*')
    tree.visit {
        source << "$project.buildDir/svn-workspace-$branch/$relVersion/$it.path"
    }
    commitMessage = "New version $branch $relVersion added"
}

task createAndPushTag {
    group = "Pre-vote phase"
    description = "Creates a release tag and pushes it to the Apache Git repository"
    dependsOn uploadToApacheDevServers
    doLast {
        println 'TODO createAndPushTag'
    }
}

task releaseOnJira {
    group = "Pre-vote phase"
    description = "Releases the version on JIRA"
    dependsOn createAndPushTag
    doLast {
        println 'TODO releaseOnJira'
    }
}

task prepareVoteThread {
    group = "Pre-vote phase"
    description = "Generates a [VOTE] thread to be tweaked and sent to the dev@ mailing list"
    dependsOn releaseOnJira
    doLast {
        println """
Below is a template email to tweak and send to the dev@ mailing list as a [VOTE] thread.
If the vote passes after 72h, run phase2.
If the vote fails or the release is cancelled, manually unrelease the version from Jira and start again.

---------------- >8 -----------------

Dear community,

I am happy to start the VOTE thread for a Groovy $relVersion release!
This release includes bugfixes for ...

The changelog for this release can be found here: https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12318123&version=12331941

Tag: https://git1-us-west.apache.org/repos/asf?p=groovy.git;a=tag;h=19f70958f39f0cc5c6b4d3e9471fd297400647d2

The artifacts to be voted on are located here: https://dist.apache.org/repos/dist/dev/groovy/$relVersion/

Release artifacts are signed with the following key: https://dist.apache.org/repos/dist/dev/groovy/KEYS

Please vote on releasing this package as Apache Groovy $relVersion.

The vote is open for the next 72 hours and passes if a majority of at least three +1 PMC votes are cast.

[ ] +1 Release Apache Groovy $relVersion
[ ]  0 I don't have a strong opinion about this, but I assume it's ok
[ ] -1 Do not release Apache Groovy $relVersion because...

Here is my vote:

+1 (binding)

---------------- >8 -----------------
"""
    }
}

[createAndPushTag, releaseOnJira, prepareVoteThread]*.onlyIf{ project.hasProperty('releaseBuild') && releaseBuild }
