import groovyx.net.http.RESTClient
import org.ajoberstar.grgit.Credentials
import org.ajoberstar.grgit.util.JGitUtil
import org.apache.tools.ant.taskdefs.condition.Os

import static groovyx.net.http.ContentType.JSON

buildscript {
    repositories {
        jcenter()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }

    dependencies {
        classpath "org.ajoberstar:grgit:${getProperty('version.grgit')}"
        classpath "at.bxm.gradleplugins:gradle-svntools-plugin:${getProperty('version.svntools')}"
        classpath "org.codehaus.groovy.modules.http-builder:http-builder:${getProperty('version.httpbuilder')}"
        classpath "org.hidetake:gradle-ssh-plugin:${getProperty('version.sshplugin')}"
        classpath "gradle.plugin.io.sdkman:gradle-sdkvendor-plugin:${getProperty('version.sdkmanplugin')}"
    }
}

ssh.settings {
    dryRun = project.hasProperty('dryRun')
    // TODO explore whether this can be made more secure - below not working on windows
//    knownHosts = file(System.getProperty('user.home') + '/.ssh/known_hosts')
    knownHosts = allowAnyHosts
}

remotes {
    ciServer {
        host = 'ci.groovy-lang.org'
        user = findProperty('ciserver.user')
        password = findProperty('ciserver.password')
        //identity = file('id_rsa')
    }
}

// use Exec rather than GradleBuild to avoid any issues between gradle versions
task websiteBuild(type: Exec, dependsOn: [assumesRelVersion, checkoutGroovyWebsite]) {
    workingDir stagingWebsiteDir
    def theArgs = []
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        theArgs += ['cmd', '/C', 'gradlew.bat']
    } else {
        theArgs << './gradlew'
    }
    theArgs << 'webzip'
    commandLine theArgs
}

// NOTE: not normally needed as part of a release since the CI server does
// this automatically upon commit of the changed website
task websitePublish(dependsOn: websiteBuild) {
    description = "Manual upload of documentation to the Groovy website server"
    doLast {
        println "WARNING: result might be overridden by CI server"
        ssh.run {
            session(remotes.ciServer) {
                execute 'uname -a'
                file("$stagingWebsiteDir/site/build/site").listFiles().each {
                    put from: it, into: '/var/www/beta'
                }
//                execute 'chgrp -R teamcity /var/www/beta'
            }
        }
    }
}

task untagVersion(dependsOn: assumesPropsSet) {
    doLast {
        def apacheCredentials = new Credentials(username: apacheUser, password: apachePassword)
        def grgit = grgitClass.open(dir: stagingDir, creds: apacheCredentials)
        def tagName = "GROOVY_$underVersion"
        def tag = null
        try {
            tag = JGitUtil.resolveTag(grgit.repository, tagName)
        } catch (ignore) {
            println "Exception message: " + ignore.message
        }
        assert tag, "Tag $tagName is supposed to exist but doesn't!"
        grgit.tag.remove(names: [tagName])
        grgit.push(tags: true)
        grgit.push(refsOrSpecs: [":refs/tags/$tagName"])
    }
}

task unreleaseOnJira(dependsOn: jiraCheckPhase2) {
    description = "Unrelease on Jira if the VOTE is cancelled"
    doLast {
        def jira = new RESTClient('https://issues.apache.org/jira/rest/api/2/')
        jira.headers['Authorization'] = 'Basic ' + "$apacheUser:$apachePassword".getBytes('iso-8859-1').encodeBase64()
        def resp = jira.put(
                path: "version/$versionId",
                body: /{ "released": false, "releaseDate": null }/,
                requestContentType: JSON
        )
        assert resp.status == 200
    }
}
